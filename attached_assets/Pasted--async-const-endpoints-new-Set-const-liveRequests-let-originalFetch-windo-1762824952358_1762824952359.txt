(async () => {
  const endpoints = new Set();
  const liveRequests = [];
  let originalFetch = window.fetch;
  let originalXHR = window.XMLHttpRequest;
  
  // Enhanced backend detection with EXTENSIVE DATABASE UPDATE patterns
  function looksLikeBackend(str) {
    return (
      str.includes("?op=") ||
      str.includes("/api/") ||
      /\.php(\?|$)/.test(str) ||
      /\.asp(x)?(\?|$)/.test(str) ||
      /\.jsp(\?|$)/.test(str) ||
      /\/cgi-bin\//.test(str) ||
      /\.cgi(\?|$)/.test(str) ||
      /\/admin\//.test(str) ||
      /\/upload/.test(str) ||
      /\/login/.test(str) ||
      /\/auth/.test(str) ||
      /\/logout/.test(str) ||
      /\.json$/.test(str) ||
      /\.xml$/.test(str) ||
      /\/graphql/.test(str) ||
      /\/webhook/.test(str) ||
      /\/password/.test(str) ||
      /\/reset/.test(str) ||
      /\/verify/.test(str) ||
      // COMPREHENSIVE DATABASE UPDATE PATTERNS
      /\/create/.test(str) ||
      /\/insert/.test(str) ||
      /\/update/.test(str) ||
      /\/delete/.test(str) ||
      /\/remove/.test(str) ||
      /\/edit/.test(str) ||
      /\/modify/.test(str) ||
      /\/save/.test(str) ||
      /\/store/.test(str) ||
      /\/add/.test(str) ||
      /\/new/.test(str) ||
      /\/submit/.test(str) ||
      /\/process/.test(str) ||
      /\/handle/.test(str) ||
      /\/publish/.test(str) ||
      /\/approve/.test(str) ||
      /\/reject/.test(str) ||
      /\/activate/.test(str) ||
      /\/deactivate/.test(str) ||
      /\/enable/.test(str) ||
      /\/disable/.test(str) ||
      /\/bulk/.test(str) ||
      /\/batch/.test(str) ||
      /\/(users|posts|comments|orders|products|customers|items|accounts|profiles)\/\d+/.test(str) ||
      /\?action=(create|update|delete|insert|edit|save|add|remove|submit|process|publish|approve)/.test(str) ||
      /\?method=(post|put|patch|delete)/.test(str) ||
      /\?cmd=(insert|update|delete|create|modify)/.test(str) ||
      /\?operation=(write|modify|change|alter)/.test(str) ||
      /\/database\//.test(str) ||
      /\/db\//.test(str) ||
      /\/sql/.test(str) ||
      /\/query/.test(str) ||
      /\/execute/.test(str) ||
      /\/transaction/.test(str) ||
      /\/commit/.test(str) ||
      /\/rollback/.test(str)
    );
  }

  // Enhanced server logic analysis with DETAILED DATABASE OPERATIONS focus
  function analyzeServerLogic(url) {
    const patterns = {
      'db-insert': /insert|create|add|new|register|signup|post(?!.*get)|submit(?!.*form)/i,
      'db-update': /update|edit|modify|change|patch|save|put|alter|set/i,
      'db-delete': /delete|remove|destroy|drop|clear|purge|erase/i,
      'db-upsert': /upsert|merge|replace|save/i,
      'db-bulk': /bulk|batch|multi|mass/i,
      'db-transaction': /transaction|commit|rollback|begin|start/i,
      'db-read': /read|get|fetch|list|view|show|select|find|search/i,
      'auth': /login|auth|signin|signup|register|token|jwt|oauth/i,
      'admin': /admin|manage|control|dashboard|panel/i,
      'upload': /upload|file|attachment|media|image/i,
      'security': /csrf|xsrf|captcha|verify|validate/i,
      'workflow': /approve|reject|publish|activate|enable|process|handle/i,
      'backup': /backup|export|import|migrate|dump|restore/i
    };
    
    const types = [];
    Object.entries(patterns).forEach(([type, regex]) => {
      if (regex.test(url)) types.push(type);
    });
    
    return types.length > 0 ? types.join(', ') : 'unknown';
  }

  // REAL payload analysis implementation
  async function analyzePayload(data) {
    if (!data) return null;
    
    try {
      let payload = data;
      let payloadStr = '';
      
      // Handle different payload types
      if (data instanceof FormData) {
        const entries = Array.from(data.entries());
        payload = Object.fromEntries(entries);
        payloadStr = JSON.stringify(payload).toLowerCase();
      } else if (typeof data === 'string') {
        payloadStr = data.toLowerCase();
        try {
          payload = JSON.parse(data);
        } catch {
          payload = data;
        }
      } else if (data instanceof URLSearchParams) {
        payload = Object.fromEntries(data.entries());
        payloadStr = JSON.stringify(payload).toLowerCase();
      } else {
        payloadStr = JSON.stringify(data).toLowerCase();
      }
      
      const analysis = {
        hasId: /["']?(?:id|_id|user_id|post_id)["']?\s*[:=]/.test(payloadStr),
        hasTimestamp: /timestamp|created_at|updated_at|date|time/.test(payloadStr),
        hasUserData: /user|email|username|password|name|profile/.test(payloadStr),
        hasFileData: /file|image|upload|attachment|media|blob/.test(payloadStr),
        hasUpdateVerbs: /update|edit|modify|change|set|save/.test(payloadStr),
        hasCreateVerbs: /create|insert|add|new/.test(payloadStr),
        hasDeleteVerbs: /delete|remove|destroy/.test(payloadStr),
        sqlKeywords: [],
        dbFields: []
      };
      
      // Check for SQL keywords
      const sqlKeywords = ['insert', 'update', 'delete', 'select', 'where', 'set', 'values'];
      sqlKeywords.forEach(keyword => {
        if (payloadStr.includes(keyword)) analysis.sqlKeywords.push(keyword);
      });
      
      // Check for common DB fields
      const dbFields = ['name', 'email', 'password', 'title', 'content', 'description', 'status', 'type'];
      dbFields.forEach(field => {
        if (payloadStr.includes(field)) analysis.dbFields.push(field);
      });
      
      return analysis;
    } catch {
      return null;
    }
  }

  // Enhanced database operation detection with REST heuristics
  function getDatabaseOperation(method, url, payloadAnalysis = null) {
    const urlLower = url.toLowerCase();
    
    // REST pattern: POST to /resource/:id typically means UPDATE
    const hasIdInPath = /\/(\w+)\/\d+/.test(urlLower);
    
    if (method === 'POST') {
      // Check payload for indicators
      if (payloadAnalysis) {
        if (payloadAnalysis.hasId || hasIdInPath) {
          if (payloadAnalysis.hasUpdateVerbs) return 'UPDATE';
          if (payloadAnalysis.hasDeleteVerbs) return 'DELETE';
          return 'UPDATE'; // POST with ID typically updates
        }
        if (payloadAnalysis.hasCreateVerbs) return 'INSERT';
        if (payloadAnalysis.hasUpdateVerbs) return 'UPDATE';
        if (payloadAnalysis.hasDeleteVerbs) return 'DELETE';
      }
      
      // URL-based detection
      if (/insert|create|add|new|register|signup|submit/.test(urlLower)) return 'INSERT';
      if (/update|edit|modify|save|set/.test(urlLower)) return 'UPDATE';
      if (/delete|remove|destroy|purge/.test(urlLower)) return 'DELETE';
      if (/upsert|merge|replace/.test(urlLower)) return 'UPSERT';
      if (/bulk|batch|multi/.test(urlLower)) return 'BULK_OP';
      if (hasIdInPath) return 'UPDATE'; // POST to /resource/:id
      
      return 'INSERT'; // Default POST assumption
    } else if (method === 'PUT') {
      return 'UPDATE/REPLACE';
    } else if (method === 'PATCH') {
      return 'PARTIAL_UPDATE';
    } else if (method === 'DELETE') {
      return 'DELETE';
    } else if (method === 'GET') {
      if (/delete|remove|destroy/.test(urlLower)) return 'DELETE_VIA_GET (unsafe)';
      if (/update|edit|modify/.test(urlLower)) return 'UPDATE_VIA_GET (unsafe)';
      return 'READ';
    }
    
    return 'UNKNOWN';
  }

  // Start intercepting live requests with PAYLOAD ANALYSIS
  function startRequestInterception() {
    console.log("üïµÔ∏è Starting enhanced database operation interception...");
    
    // Intercept fetch requests with payload analysis
    window.fetch = async function(...args) {
      const startTime = performance.now();
      let url = typeof args[0] === 'string' ? args[0] : args[0]?.url;
      let method = args[1]?.method || 'GET';
      let payload = args[1]?.body || null;
      
      try {
        const response = await originalFetch.apply(this, args);
        const duration = Math.round(performance.now() - startTime);
        
        if (looksLikeBackend(url)) {
          const payloadAnalysis = await analyzePayload(payload);
          const logicType = analyzeServerLogic(url);
          const dbOp = getDatabaseOperation(method, url, payloadAnalysis);
          
          let payloadInfo = '';
          if (payloadAnalysis) {
            const features = [];
            if (payloadAnalysis.hasId) features.push('ID');
            if (payloadAnalysis.hasUserData) features.push('USER_DATA');
            if (payloadAnalysis.hasTimestamp) features.push('TIMESTAMP');
            if (payloadAnalysis.hasFileData) features.push('FILE_DATA');
            if (payloadAnalysis.hasUpdateVerbs) features.push('UPDATE_VERBS');
            if (payloadAnalysis.hasCreateVerbs) features.push('CREATE_VERBS');
            if (payloadAnalysis.hasDeleteVerbs) features.push('DELETE_VERBS');
            if (payloadAnalysis.sqlKeywords.length > 0) features.push(`SQL:${payloadAnalysis.sqlKeywords.join(',')}`);
            if (features.length > 0) payloadInfo = ` PAYLOAD:[${features.join('|')}]`;
          }
          
          const entry = `${method} ${url} ‚Üí ${response.status} (${duration}ms) [DB:${dbOp}] [${logicType}]${payloadInfo}   ‚Üê LIVE REQUEST`;
          endpoints.add(entry);
          liveRequests.push({
            url, 
            method, 
            status: response.status, 
            duration, 
            dbOperation: dbOp, 
            type: logicType,
            payloadAnalysis
          });
          console.log(`üåê ${entry}`);
        }
        
        return response;
      } catch (error) {
        if (looksLikeBackend(url)) {
          const dbOp = getDatabaseOperation(method, url);
          const entry = `${method} ${url} ‚Üí ERROR: ${error.message} [DB:${dbOp}]   ‚Üê LIVE REQUEST`;
          endpoints.add(entry);
          console.warn(`üåê ${entry}`);
        }
        throw error;
      }
    };

    // Intercept XMLHttpRequest with payload analysis
    window.XMLHttpRequest = function() {
      const xhr = new originalXHR();
      const originalOpen = xhr.open;
      const originalSend = xhr.send;
      let method, url, startTime, payload;

      xhr.open = function(m, u, ...args) {
        method = m.toUpperCase();
        url = u;
        return originalOpen.apply(this, [m, u, ...args]);
      };

      xhr.send = function(data) {
        startTime = performance.now();
        payload = data;
        
        xhr.addEventListener('loadend', async () => {
          const duration = Math.round(performance.now() - startTime);
          
          if (looksLikeBackend(url)) {
            const payloadAnalysis = await analyzePayload(payload);
            const logicType = analyzeServerLogic(url);
            const dbOp = getDatabaseOperation(method, url, payloadAnalysis);
            
            let payloadInfo = '';
            if (payloadAnalysis) {
              const features = [];
              if (payloadAnalysis.hasId) features.push('ID');
              if (payloadAnalysis.hasUserData) features.push('USER_DATA');
              if (payloadAnalysis.hasTimestamp) features.push('TIMESTAMP');
              if (payloadAnalysis.hasFileData) features.push('FILE_DATA');
              if (payloadAnalysis.hasUpdateVerbs) features.push('UPDATE_VERBS');
              if (payloadAnalysis.hasCreateVerbs) features.push('CREATE_VERBS');
              if (payloadAnalysis.hasDeleteVerbs) features.push('DELETE_VERBS');
              if (payloadAnalysis.sqlKeywords.length > 0) features.push(`SQL:${payloadAnalysis.sqlKeywords.join(',')}`);
              if (features.length > 0) payloadInfo = ` PAYLOAD:[${features.join('|')}]`;
            }
            
            const entry = `${method} ${url} ‚Üí ${xhr.status} (${duration}ms) [DB:${dbOp}] [${logicType}]${payloadInfo}   ‚Üê LIVE XHR`;
            endpoints.add(entry);
            liveRequests.push({
              url, 
              method, 
              status: xhr.status, 
              duration, 
              dbOperation: dbOp, 
              type: logicType,
              payloadAnalysis
            });
            console.log(`üåê ${entry}`);
          }
        });

        return originalSend.apply(this, [data]);
      };

      return xhr;
    };
    Object.setPrototypeOf(window.XMLHttpRequest, originalXHR);
  }

  // Enhanced script scanning with COMPREHENSIVE DATABASE PATTERNS
  async function scanScriptContent(code, source) {
    const patterns = [
      /["'`]([^"'`\n\r]{3,200})["'`]/g,  // Regular strings
      /url\s*:\s*["'`]([^"'`\n\r]+)["'`]/g,  // URL properties
      /fetch\s*\(\s*["'`]([^"'`\n\r]+)["'`]/g,  // Fetch calls
      /action\s*=\s*["'`]([^"'`\n\r]+)["'`]/g,  // Form actions
      /href\s*=\s*["'`]([^"'`\n\r]+)["'`]/g,  // Links
      /axios\.[a-z]+\s*\(\s*["'`]([^"'`\n\r]+)["'`]/g,  // Axios calls
      /\$\.(?:get|post|ajax|put|delete)\s*\(\s*["'`]([^"'`\n\r]+)["'`]/g,  // jQuery
      // DATABASE-SPECIFIC PATTERNS
      /\.(create|insert|update|delete|save|store|upsert|merge)\s*\(\s*["'`]([^"'`\n\r]+)["'`]/g,  // ORM methods
      /\.(?:findOneAndUpdate|findByIdAndUpdate|updateOne|updateMany|deleteOne|deleteMany|insertOne|insertMany)\s*\(\s*["'`]([^"'`\n\r]+)["'`]/g,  // MongoDB methods
      /\.(?:create|save|update|destroy|delete)\s*\(\s*["'`]([^"'`\n\r]+)["'`]/g,  // ActiveRecord/Eloquent
      /execute\s*\(\s*["'`]([^"'`\n\r]*(?:INSERT|UPDATE|DELETE|CREATE|MERGE|UPSERT)[^"'`\n\r]*)["'`]/gi,  // SQL execution
      /query\s*\(\s*["'`]([^"'`\n\r]*(?:INSERT|UPDATE|DELETE|CREATE|MERGE|UPSERT)[^"'`\n\r]*)["'`]/gi,  // SQL queries
      /sql\s*[:=]\s*["'`]([^"'`\n\r]*(?:INSERT|UPDATE|DELETE|CREATE|MERGE|UPSERT)[^"'`\n\r]*)["'`]/gi,  // SQL assignments
      /prepare\s*\(\s*["'`]([^"'`\n\r]*(?:INSERT|UPDATE|DELETE|CREATE)[^"'`\n\r]*)["'`]/gi,  // Prepared statements
      /exec\s*\(\s*["'`]([^"'`\n\r]*(?:INSERT|UPDATE|DELETE|CREATE)[^"'`\n\r]*)["'`]/gi,  // Execute statements
      // FORM SUBMISSION PATTERNS
      /submit\s*\(\s*["'`]([^"'`\n\r]+)["'`]/g,  // Form submissions
      /postData\s*[:=]\s*["'`]([^"'`\n\r]+)["'`]/g,  // POST data
      /formData\s*[:=]\s*["'`]([^"'`\n\r]+)["'`]/g   // Form data
    ];

    patterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(code)) !== null) {
        const clean = match[1] || match[2];
        if (clean && !clean.startsWith('data:') && !clean.startsWith('javascript:') && 
            !clean.startsWith('mailto:') && !clean.startsWith('#')) {
          if (looksLikeBackend(clean)) {
            const logicType = analyzeServerLogic(clean);
            const dbOp = getDatabaseOperation('UNKNOWN', clean);
            endpoints.add(`${clean} [DB:${dbOp}] [${logicType}]   ‚Üê from ${source}`);
          }
        }
      }
    });
  }

  // Start live interception first
  startRequestInterception();

  const scripts = [...document.querySelectorAll("script")];
  console.log(`üìÑ Scanning ${scripts.length} scripts for comprehensive database endpoints...`);

  // Enhanced script processing
  for (let i = 0; i < scripts.length; i++) {
    const script = scripts[i];
    
    if (script.src) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        
        const res = await fetch(script.src, { 
          signal: controller.signal,
          headers: { 'Accept': 'application/javascript, text/javascript, */*' }
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) {
          console.warn(`‚ö†Ô∏è HTTP ${res.status} for script: ${script.src}`);
          continue;
        }
        
        const text = await res.text();
        await scanScriptContent(text, script.src);
      } catch (err) {
        if (err.name === 'AbortError') {
          console.warn("‚è±Ô∏è Timeout fetching script:", script.src);
        } else {
          console.warn("‚ö†Ô∏è Couldn't fetch script:", script.src, err.message);
        }
      }
    } else if (script.innerText || script.textContent) {
      await scanScriptContent(script.innerText || script.textContent, `inline-script-${i}`);
    }
  }

  // Scan DOM elements for database forms with enhanced analysis
  const forms = document.querySelectorAll('form[action]');
  forms.forEach((form, i) => {
    if (form.action && looksLikeBackend(form.action)) {
      const method = (form.method || 'POST').toUpperCase();
      const logicType = analyzeServerLogic(form.action);
      const dbOp = getDatabaseOperation(method, form.action);
      
      // Analyze form fields for database indicators
      const inputs = form.querySelectorAll('input, textarea, select');
      const fieldNames = Array.from(inputs).map(input => input.name || input.id).filter(Boolean);
      const hasDbFields = fieldNames.some(name => 
        /id|name|email|password|title|content|description|status|type|category/.test(name.toLowerCase())
      );
      
      const fieldInfo = hasDbFields ? ` FIELDS:[${fieldNames.slice(0,5).join(',')}]` : '';
      endpoints.add(`${method} ${form.action} [DB:${dbOp}] [${logicType}]${fieldInfo}   ‚Üê from form-${i}`);
    }
  });

  const links = document.querySelectorAll('a[href]');
  links.forEach(link => {
    if (link.href && looksLikeBackend(link.href)) {
      const logicType = analyzeServerLogic(link.href);
      const dbOp = getDatabaseOperation('GET', link.href);
      endpoints.add(`${link.href} [DB:${dbOp}] [${logicType}]   ‚Üê from link`);
    }
  });

  // Results and comprehensive DATABASE analysis
  const endpointArray = [...endpoints];
  const databaseOperations = {
    'INSERT/CREATE': endpointArray.filter(e => e.includes('[DB:INSERT') || e.includes('[DB:WRITE_OP')).length,
    'UPDATE/EDIT': endpointArray.filter(e => e.includes('[DB:UPDATE') || e.includes('[DB:PARTIAL_UPDATE')).length,
    'DELETE/REMOVE': endpointArray.filter(e => e.includes('[DB:DELETE')).length,
    'UPSERT/MERGE': endpointArray.filter(e => e.includes('[DB:UPSERT')).length,
    'BULK_OPERATIONS': endpointArray.filter(e => e.includes('[DB:BULK')).length,
    'READ/SELECT': endpointArray.filter(e => e.includes('[DB:READ')).length,
    'PAYLOAD_DETECTED': endpointArray.filter(e => e.includes('PAYLOAD:')).length
  };

  const serverLogic = {
    auth: endpointArray.filter(e => e.includes('auth')).length,
    admin: endpointArray.filter(e => e.includes('admin')).length,
    upload: endpointArray.filter(e => e.includes('upload')).length,
    security: endpointArray.filter(e => e.includes('security')).length,
    workflow: endpointArray.filter(e => e.includes('workflow')).length,
    api: endpointArray.filter(e => e.includes('/api/')).length
  };

  console.log("üîç Comprehensive database endpoints detected:");
  console.table(endpointArray.map((endpoint, i) => ({ '#': i + 1, 'Endpoint': endpoint })));
  
  console.log("\nüíæ DATABASE OPERATIONS ANALYSIS:");
  console.table(databaseOperations);
  
  console.log("\nüìä Server Logic Analysis:");
  console.table(serverLogic);

  if (liveRequests.length > 0) {
    console.log("\nüåê Live database requests with payload analysis:");
    console.table(liveRequests);
  }

  console.log("\nüí° Enhanced database monitoring ACTIVE with payload analysis!");
  console.log("üìù Access: window.foundEndpoints, window.databaseOperations, window.liveRequests");
  console.log("üõë Use window.stopInterception() to stop monitoring");

  // Global access
  window.foundEndpoints = endpointArray;
  window.liveRequests = liveRequests;
  window.databaseOperations = databaseOperations;
  window.serverLogic = serverLogic;
  window.stopInterception = () => {
    window.fetch = originalFetch;
    window.XMLHttpRequest = originalXHR;
    console.log("üõë Enhanced database request interception stopped");
  };
})();